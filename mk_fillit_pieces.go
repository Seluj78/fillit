package main

import (
	"bytes"
	"math/rand"
	"os"
	"time"
)

type maxOff struct {
	x, y int
}

var pMaxOff = map[int]maxOff{
	0:  {3, 0},
	1:  {0, 3},
	2:  {2, 2},
	3:  {2, 1},
	4:  {2, 1},
	5:  {2, 1},
	6:  {2, 1},
	7:  {1, 2},
	8:  {1, 2},
	9:  {1, 2},
	10: {1, 2},
	11: {1, 2},
	12: {1, 2},
	13: {2, 1},
	14: {2, 1},
	15: {1, 2},
	16: {2, 1},
	17: {1, 2},
	18: {2, 1},
}

var pRaw = map[int][4][]byte{
	0:  {{'#', '.', '.', '.'}, {'#', '.', '.', '.'}, {'#', '.', '.', '.'}, {'#', '.', '.', '.'}},
	1:  {{'#', '#', '#', '#'}, {'.', '.', '.', '.'}, {'.', '.', '.', '.'}, {'.', '.', '.', '.'}},
	2:  {{'#', '#', '.', '.'}, {'#', '#', '.', '.'}, {'.', '.', '.', '.'}, {'.', '.', '.', '.'}},
	3:  {{'#', '.', '.', '.'}, {'#', '.', '.', '.'}, {'#', '#', '.', '.'}, {'.', '.', '.', '.'}},
	4:  {{'#', '#', '.', '.'}, {'#', '.', '.', '.'}, {'#', '.', '.', '.'}, {'.', '.', '.', '.'}},
	5:  {{'.', '#', '.', '.'}, {'.', '#', '.', '.'}, {'#', '#', '.', '.'}, {'.', '.', '.', '.'}},
	6:  {{'#', '#', '.', '.'}, {'.', '#', '.', '.'}, {'.', '#', '.', '.'}, {'.', '.', '.', '.'}},
	7:  {{'#', '#', '#', '.'}, {'#', '.', '.', '.'}, {'.', '.', '.', '.'}, {'.', '.', '.', '.'}},
	8:  {{'#', '#', '#', '.'}, {'.', '.', '#', '.'}, {'.', '.', '.', '.'}, {'.', '.', '.', '.'}},
	9:  {{'#', '.', '.', '.'}, {'#', '#', '#', '.'}, {'.', '.', '.', '.'}, {'.', '.', '.', '.'}},
	10:  {{'.', '.', '#', '.'}, {'#', '#', '#', '.'}, {'.', '.', '.', '.'}, {'.', '.', '.', '.'}},
	11:  {{'.', '#', '#', '.'}, {'#', '#', '.', '.'}, {'.', '.', '.', '.'}, {'.', '.', '.', '.'}},
	12:  {{'#', '#', '.', '.'}, {'.', '#', '#', '.'}, {'.', '.', '.', '.'}, {'.', '.', '.', '.'}},
	13: {{'#', '.', '.', '.'}, {'#', '#', '.', '.'}, {'.', '#', '.', '.'}, {'.', '.', '.', '.'}},
	14: {{'.', '#', '.', '.'}, {'#', '#', '.', '.'}, {'#', '.', '.', '.'}, {'.', '.', '.', '.'}},
	15:  {{'.', '#', '.', '.'}, {'#', '#', '#', '.'}, {'.', '.', '.', '.'}, {'.', '.', '.', '.'}},
	16: {{'#', '.', '.', '.'}, {'#', '#', '.', '.'}, {'#', '.', '.', '.'}, {'.', '.', '.', '.'}},
	17: {{'#', '#', '#', '.'}, {'.', '#', '.', '.'}, {'.', '.', '.', '.'}, {'.', '.', '.', '.'}},
	18: {{'.', '#', '.', '.'}, {'#', '#', '.', '.'}, {'.', '#', '.', '.'}, {'.', '.', '.', '.'}},
}

func AddPiece(b *bytes.Buffer) {
	pNum := rand.Intn(len(pRaw))
	offX := rand.Intn(pMaxOff[pNum].x + 1)
	offY := rand.Intn(pMaxOff[pNum].y + 1)
	for i := 0; i < offY; i++ {
		b.Write([]byte{'.', '.', '.', '.', '\n'})
	}
	for i := 0; i < 4-offY; i++ {
		b.Write([]byte{'.', '.', '.', '.'}[:offX])
		b.Write(pRaw[pNum][i][:4-offX])
		b.WriteByte('\n')
	}
}

func main() {
	var b bytes.Buffer

	rand.Seed(time.Now().UnixNano())
	n := rand.Intn(26)
	for i := 0; i <= n; i++ {
		AddPiece(&b)
		if i != n {
			b.WriteByte('\n')
		}
	}
	b.WriteTo(os.Stdout)
}
